Directory structure:
└── n0tif/
    ├── main.go
    └── service.go

================================================
File: main.go
================================================
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strconv"
	"syscall"

	"github.com/byigitt/n0tif/config"
	"github.com/byigitt/n0tif/internal/email"
	"github.com/byigitt/n0tif/internal/notify"
	"github.com/byigitt/n0tif/internal/storage"
)

// Global flags for application configuration
var (
	imapServer  = flag.String("server", "", "IMAP server address")
	imapPort    = flag.Int("port", 993, "IMAP server port")
	username    = flag.String("user", "", "Email username/address")
	password    = flag.String("pass", "", "Email password")
	interval    = flag.Int("interval", 60, "Check interval in seconds")
	save        = flag.Bool("save", false, "Save credentials for future use")
	background  = flag.Bool("background", false, "Run in background (can be closed via Task Manager)")
	serviceMode = flag.Bool("service", false, "Install and run as Windows service (auto-starts with Windows)")
	isDaemon    = flag.Bool("daemon", false, "Internal use: Indicates process is a daemon child")
)

func main() {
	flag.Parse() // Parse all flags once at the beginning

	if *isDaemon {
		// If this is a daemon child, its stdout/stderr might be nil (set by parent).
		// setupFileLogging will attempt to redirect log.* to a file.
		// If setupFileLogging fails, its log.Fatal will try to use original stderr (which is nil) and exit.
		setupFileLogging()
		log.Println("N0tif daemon process initialised with file logging.")
	}

	appCfgEmail := loadAppConfig() // Centralized config loading, uses global parsed flags

	if *serviceMode {
		// service.go's runAsWindowsService handles its own logging via setupServiceLogging (which also sets log.SetOutput).
		// The 'true' here is for the installAndStart parameter in runAsWindowsService.
		runAsWindowsService(appCfgEmail, true, os.Args[1:])
		return
	}

	if *background {
		runInBackground(appCfgEmail) // Pass fully resolved config
		return
	}

	// Foreground execution
	if !*isDaemon { // Only print this if truly foreground, not a -daemon child being run directly for testing
		log.Println("Starting N0tif - Email Notification Service (Foreground)")
	}
	runEmailMonitor(appCfgEmail)
}

// loadAppConfig resolves the email configuration from flags or storage.
// It uses the globally parsed flags.
// It will log.Fatal if essential configuration is missing and not loadable.
func loadAppConfig() config.EmailConfig {
	cfg := config.GetDefaultConfig() // Start with defaults

	// Check if essential credential flags were explicitly set by the user on the command line.
	// A simple check is if they are different from their zero/default values after flag.Parse().
	// More robust: use flag.Visit to see which flags were actually set.
	// For now, we assume if they are non-empty/non-default, they were set.
	hasExplicitServer := *imapServer != ""
	hasExplicitUser := *username != ""
	hasExplicitPass := *password != ""
	// For port and interval, we can check if they differ from default if needed, or assume if primary creds are set, these are also intended.

	usingSavedCreds := false
	// If no primary credential flags were set, try to load from storage.
	if !hasExplicitServer && !hasExplicitUser && !hasExplicitPass {
		if storage.CredentialsExist() {
			log.Println("No explicit credentials provided via flags, attempting to load saved credentials...")
			savedCfg, err := storage.LoadCredentials()
			if err != nil {
				log.Fatalf("Failed to load saved credentials: %v. Please provide credentials or use -save.", err)
			}
			cfg.Email = *savedCfg
			usingSavedCreds = true
			log.Printf("Loaded credentials for %s@%s", savedCfg.Username, savedCfg.ImapServer)
		} else {
			// If this is a daemon child, it MUST have received explicit args from its parent (runInBackground).
			// So if it reaches here, something is wrong with how it was launched or parsed its args.
			if *isDaemon {
				log.Fatal("CRITICAL_DAEMON_CONFIG_ERROR: Daemon started without necessary credential arguments and no saved credentials found. This indicates an issue with parent process argument passing.")
			} else {
				log.Fatal("No credentials provided and no saved credentials found. Required flags: -server, -user, -pass, or use -save.")
			}
		}
	} else {
		// Use explicitly provided flags if they were set
		// This part assumes that if any of server/user/pass is set, all required ones should be set.
		if hasExplicitServer {
			cfg.Email.ImapServer = *imapServer
		}
		if *imapPort != config.GetDefaultConfig().Email.ImapPort {
			cfg.Email.ImapPort = *imapPort
		}
		if hasExplicitUser {
			cfg.Email.Username = *username
		}
		if hasExplicitPass {
			cfg.Email.Password = *password
		}
		if *interval != config.GetDefaultConfig().Email.CheckInterval {
			cfg.Email.CheckInterval = *interval
		}
	}

	// Final validation for all paths
	if cfg.Email.ImapServer == "" || cfg.Email.Username == "" || cfg.Email.Password == "" {
		log.Fatal("Missing required email configuration: server, username, and password are required.")
	}

	// Save credentials if -save flag is present AND we are using explicitly provided flags (not loaded ones).
	if *save && (hasExplicitServer || hasExplicitUser || hasExplicitPass) && !usingSavedCreds {
		log.Println("Saving provided credentials...")
		if err := storage.SaveCredentials(cfg.Email); err != nil {
			log.Printf("Warning: Failed to save credentials: %v", err)
		} else {
			log.Println("Credentials saved successfully.")
		}
	}
	return cfg.Email
}

// runEmailMonitor contains the main logic. Assumes logging is pre-configured.
func runEmailMonitor(emailCfg config.EmailConfig) {
	log.Println("runEmailMonitor: Initializing with loaded/parsed config.")
	imapChecker, err := email.NewImapChecker(emailCfg)
	if err != nil {
		log.Fatalf("Failed to initialize email checker: %v", err)
	}

	log.Println("Initializing email tracking...")
	if err := imapChecker.InitializeEmailTracking(); err != nil {
		log.Printf("Warning: Failed to initialize email tracking: %v", err)
	} else {
		log.Println("Email tracking initialized successfully.")
	}

	handleNewEmails := func(subjects []string) {
		if len(subjects) == 0 {
			return
		}
		notificationTitle := "New Email"
		notificationMessage := fmt.Sprintf("You have a new email: %s", subjects[0])
		if len(subjects) > 1 {
			notificationTitle = "New Emails"
			notificationMessage = fmt.Sprintf("You have %d new emails", len(subjects))
		}
		if errNotify := notify.SendWindowsNotification(notificationTitle, notificationMessage, true); errNotify != nil {
			log.Printf("Failed to send notification: %v", errNotify)
		}
	}

	imapChecker.StartChecking(handleNewEmails)
	log.Printf("Email checker started for %s. Checking every %d seconds.", emailCfg.Username, emailCfg.CheckInterval)

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	log.Println("Shutting down...")
}

// runInBackground relaunches the application as a background (detached) process.
func runInBackground(emailCfg config.EmailConfig) {
	exePath, err := os.Executable()
	if err != nil {
		log.Fatalf("Failed to get executable path: %v", err)
	}

	args := []string{
		"-daemon",
		"-server", emailCfg.ImapServer,
		"-port", strconv.Itoa(emailCfg.ImapPort),
		"-user", emailCfg.Username,
		"-pass", emailCfg.Password,
		"-interval", strconv.Itoa(emailCfg.CheckInterval),
	}

	cmd := exec.Command(exePath, args...)
	cmd.Stdout = nil // Redirect child's stdout to nil
	cmd.Stderr = nil // Redirect child's stderr to nil
	cmd.SysProcAttr = &syscall.SysProcAttr{
		CreationFlags: syscall.CREATE_NEW_PROCESS_GROUP | 0x00000008, // DETACHED_PROCESS
	}

	if err := cmd.Start(); err != nil {
		log.Fatalf("Failed to start background process: %v", err)
	}

	fmt.Printf("N0tif has been started in the background (PID: %d)\n", cmd.Process.Pid)
	fmt.Printf("You can close it from Task Manager using this PID.\n")
	configDir, _ := os.UserConfigDir()
	logPath := filepath.Join(configDir, "n0tif", "n0tif.log")
	fmt.Printf("Logs can be found at: %s\n", logPath)
	os.Exit(0)
}

// setupFileLogging configures file logging.
// It is called very early in main() if the -daemon flag is set.
// If it fails, it calls log.Fatalf(), which will attempt to write to original stderr.
// For a daemon whose stderr is nil, this means a silent exit.
func setupFileLogging() {
	configDir, err := os.UserConfigDir()
	if err != nil {
		log.Fatalf("CRITICAL_ERROR: Failed to get user config directory for logging: %v", err)
	}
	logDir := filepath.Join(configDir, "n0tif")
	if err := os.MkdirAll(logDir, 0755); err != nil {
		log.Fatalf("CRITICAL_ERROR: Failed to create log directory '%s': %v", logDir, err)
	}
	logFile := filepath.Join(logDir, "n0tif.log")

	f, err := os.OpenFile(logFile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("CRITICAL_ERROR: Failed to open log file '%s': %v", logFile, err)
	}

	log.SetOutput(f)
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
	// Do not return 'f' as we are not redirecting stdout/stderr with Dup2 anymore.
	// The file will be implicitly closed on process exit or if logger is reconfigured.
}



================================================
File: service.go
================================================
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/byigitt/n0tif/config"
	"github.com/kardianos/service"
)

// Define service configuration
var serviceConfig = &service.Config{
	Name:        "N0tifEmailService",
	DisplayName: "N0tif Email Notification Service",
	Description: "Checks for new emails and sends Windows notifications",
}

// Service struct to hold state
type n0tifService struct {
	emailCfg config.EmailConfig
	logger   service.Logger
}

// Start implements the service.Service interface
func (s *n0tifService) Start(svc service.Service) error {
	// Start should not block. Do the work in a goroutine.
	go s.run()
	return nil
}

// Stop implements the service.Service interface
func (s *n0tifService) Stop(svc service.Service) error {
	// Perform cleanup tasks if any
	log.Println("N0tif service stopping.")
	return nil
}

// run does the actual work of monitoring emails
func (s *n0tifService) run() {
	// The service is inherently a daemon, so pass true for daemonMode.
	// The EmailConfig is now directly available in s.emailCfg.
	log.Println("N0tif service run method executing runEmailMonitor.")
	runEmailMonitor(s.emailCfg)
}

// setupServiceLogging configures logging to go to both the service log and our custom log file
func setupServiceLogging(svc service.Service) {
	// Get service logger
	var err error
	_, err = svc.Logger(nil)
	if err != nil {
		log.Printf("Failed to get service logger: %v", err)
	}

	// Configure custom log file as well, this will be used by runEmailMonitor
	appDataDir := os.Getenv("APPDATA")
	logDir := filepath.Join(appDataDir, "n0tif")

	// Create directory if it doesn't exist
	if err := os.MkdirAll(logDir, 0755); err != nil {
		log.Printf("Failed to create log directory: %v", err)
		return
	}

	logFile := filepath.Join(logDir, "n0tif.log")
	f, err := os.OpenFile(logFile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Printf("Failed to open log file: %v", err)
		return
	}

	// Set standard log output to this file. This will be used by runEmailMonitor.
	log.SetOutput(f)
	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)
	log.Println("Service logging configured to file.")
}

// runAsWindowsService attempts to run the program as a Windows service
// Takes resolved EmailConfig now
func runAsWindowsService(emailCfg config.EmailConfig, installAndStart bool, serviceArgs []string) {
	prg := &n0tifService{
		emailCfg: emailCfg,
	}
	svc, err := service.New(prg, serviceConfig)
	if err != nil {
		log.Fatalf("Failed to create service: %v", err)
	}

	// Setup logging. This needs to happen before Install/Start/Run calls
	// that might log through the service logger or our file logger.
	// Crucially, if the service runs, runEmailMonitor will use this logging setup.
	setupServiceLogging(svc)

	if installAndStart {
		// Attempt to control the service (install, start)
		// Check service.Control first if specific action like "install" is passed in serviceArgs
		if len(serviceArgs) > 0 {
			serviceAction := serviceArgs[0]
			if serviceAction == "install" || serviceAction == "uninstall" || serviceAction == "start" || serviceAction == "stop" {
				err := service.Control(svc, serviceAction)
				if err != nil {
					log.Fatalf("Failed to %s service: %v", serviceAction, err)
				}
				fmt.Printf("Service %s action successful.\n", serviceAction)
				return
			}
		}

		// Default install and start logic if no specific control action
		status, errStatus := svc.Status()
		if errStatus != nil { // Error means service is likely not installed
			log.Println("Service not found or status error, attempting to install...")
			if errInstall := svc.Install(); errInstall != nil {
				log.Fatalf("Failed to install service: %v", errInstall)
			}
			log.Println("Service installed successfully.")
			status = service.StatusStopped // Assume it's stopped after install
		}

		if status != service.StatusRunning {
			log.Println("Service not running, attempting to start...")
			if errStart := svc.Start(); errStart != nil {
				log.Fatalf("Failed to start service: %v", errStart)
			}
			log.Println("Service started successfully.")
		} else {
			log.Println("Service is already running.")
		}
		fmt.Println("N0tif service is configured and running.")
		fmt.Printf("Logs are at: %s\\n0tif\\n0tif.log\n", os.Getenv("APPDATA"))
		return
	}

	// If not installing/starting, just run the service (e.g., when SCM starts it)
	log.Println("Running service directly (e.g., started by SCM).")
	if errRun := svc.Run(); errRun != nil {
		log.Fatalf("Failed to run service: %v", errRun)
	}
}


